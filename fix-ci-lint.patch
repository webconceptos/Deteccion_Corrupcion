*** Begin Patch
*** Update File: .github/workflows/ci.yml
@@
 name: CI
 
 on:
   push:
     branches: [ main, develop, "feat/**", "fix/**" ]
   pull_request:
     branches: [ main, develop ]
 
 jobs:
   build-test:
     runs-on: ubuntu-latest
 
     steps:
       - name: Checkout
         uses: actions/checkout@v4
 
       - name: Setup Python
         uses: actions/setup-python@v5
         with:
           python-version: "3.11"
 
       - name: Cache pip
         uses: actions/cache@v4
         with:
           path: ~/.cache/pip
           key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}
           restore-keys: |
             ${{ runner.os }}-pip-
 
       - name: Install deps
         run: |
           python -m pip install --upgrade pip
           pip install -r requirements.txt
           if [ -f requirements-dev.txt ]; then pip install -r requirements-dev.txt; fi
 
       - name: Lint (ruff)
         run: |
           ruff check .
           ruff format --check .
 
       - name: Unit tests (pytest)
         env:
           PYTHONPATH: .
         run: |
           pytest -q
 
-      - name: API smoke test (fastapi)
-        if: always()
-        env:
-          PYTHONPATH: .
-        run: |
-          python - << 'PY'
-          import json
-          from fastapi.testclient import TestClient
-          from src.api.main import app
-          c = TestClient(app)
-          r = c.get("/health"); assert r.status_code == 200
-          m = c.get("/model_meta"); assert m.status_code == 200
-          print("SMOKE OK")
-          PY
+      - name: API smoke test (fastapi, mocked model)
+        if: always()
+        env:
+          PYTHONPATH: .
+        run: |
+          python - << 'PY'
+          # --- Mock del modelo para evitar depender de artefactos reales en CI ---
+          from fastapi.testclient import TestClient
+          from src.api import deps
+          from src.api.main import app
+
+          class _DummyPipe:
+              def predict_proba(self, X):
+                  import numpy as np
+                  # siempre 0.7 para la clase 1
+                  return np.c_[1-np.full(len(X), 0.7), np.full(len(X), 0.7)]
+
+          def _fake_get():
+              return _DummyPipe(), {"columns": ["a","b"], "best_threshold_f1": 0.6}
+
+          try:
+              deps.get_model_and_meta.cache_clear()
+          except Exception:
+              pass
+          deps.get_model_and_meta = _fake_get  # monkeypatch simple
+
+          c = TestClient(app)
+          assert c.get("/health").status_code == 200
+          # model_meta debe responder aunque no haya artefactos reales
+          r = c.get("/model_meta")
+          assert r.status_code == 200
+          assert "best_threshold_f1" in r.json()
+          print("SMOKE OK")
+          PY
*** End Patch
